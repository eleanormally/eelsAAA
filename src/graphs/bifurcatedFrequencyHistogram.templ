package graphs

import (
	"fmt"
	"github.com/jackc/pgx/v5/pgxpool"
)

type entry struct {
	Word string  `json:"word"`
	Time float32 `json:"time"`
	Freq string  `json:"freq"`
	Aoa  string  `json:"aoa"`
}

script listEntries(entries []entry, id string) {
  const svg = d3.select("#"+id)
  let g = svg.append("g")

  const margin = 25
  const width = 800
  const height = 1200

  const maxVal = d3.max(entries, (d) => d.time)

  const y = d3.scaleBand()
    .domain(d3.groupSort(entries, ([d]) => -d.time, (d) => d.word))
    .range([margin, height-margin])
    .padding(.2)

  const x = d3.scaleLinear().domain([-maxVal, maxVal]).range([margin,width-margin])


  let tt = d3.select("body")
        .append("div")
  tt.attr("id", "timett")
    .attr("class", "drop-shadow-md text-sm rounded-md p-1 border-1 border-grey bg-white flex flex-col")
    .style("position", "absolute")
    .style("visibility", "hidden")
  svg.on('mousemove', function(event) {
      tt.style("left", event.pageX - 10)
         .style("top", event.pageY + 10)
    });
  
  g.selectAll().data(entries)
     .join("rect")
        .attr("y", (d) => y(d.word))
        .attr("height", y.bandwidth())
        .attr("width", (d) => x(d.time)-x(0))
        .on("mouseover", function(event, d) {
            d3.select(this).transition().duration(100).style("opacity", 0.85)
            tt.html(`
              <span>${d.word}: ${d.time.toFixed(0)}ms</span>
              `)
            tt.style("visibility", "visible")
        })
        .on("mouseout", function(event, d) {
          d3.select(this).transition().duration(100).style("opacity", 1)
          tt.style("visibility", "hidden")
        })
  g.selectAll("text").data(entries).enter()
      .append("text")
        .text((d) => d.time)
        .attr("y", (d) => y(d.word)+y.bandwidth()-1)
        .style("fill", "white")
        .style("font-size", y.bandwidth()+"px")
        .style("pointer-events", "none")

      g.selectAll("rect").data(entries)
      .attr("fill", (d) => d3.hsl(20, 0.75, d.freq === "high" ? 0.6 : 0.4).formatHex())
      .attr("x", (d) => {
        if(d.freq === "low") {
          return x(-d.time)
        } else {
          return x(0)
        }
      })
      g.selectAll("text").data(entries)
        .attr("x", (d) => {
          if(d.freq === "low") {
            return x(-d.time)+10
          }
          else {
            return x(d.time)-10
          }
          })
        .style("text-anchor", (d) => d.freq === "low" ? "start" : "end")

}

func getData(db *pgxpool.Pool) ([]entry, error) {
	var entries []entry
	values, err := db.Query(context.Background(),
		`SELECT wp.word, avg(r.time) as time, wp.freq, wp.aoa from results as r 
		inner join 
		"wordPairs" as wp on wp.id = r.pair_id where r.correct = true and r.word = true
		group by wp.word, wp.aoa, wp.freq`,
	)
	defer values.Close()
	if err != nil {
		return nil, err
	}
	for values.Next() {
		var entry entry
		values.Scan(&entry.Word, &entry.Time, &entry.Freq, &entry.Aoa)
		entries = append(entries, entry)
	}
	return entries, nil

}

func BifurcatedFrequencyHistogram(db *pgxpool.Pool) templ.Component {
	entries, err := getData(db)

	if err != nil {
		fmt.Println("entries error: " + err.Error())

	}
	return displayHistogram(entries)

}

templ displayHistogram(entries []entry) {
	<div id="fig6">
		@graphBase(
			"Figure 6",
			`On the left are words with a low frequency in english,
									    on the right are those with a higher frequency.`,
			svgComponent("0 0 800 1200", "freqHisto"),
		)
		@listEntries(entries, "freqHisto")
	</div>
}
