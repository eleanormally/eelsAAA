package graphs

import (
	"fmt"
	"github.com/jackc/pgx/v5/pgxpool"
)

type entry struct {
	Word string  `json:"word"`
	Time float32 `json:"time"`
	Freq string  `json:"freq"`
	Aoa  string  `json:"aoa"`
}

script listEntries(entries []entry, id string) {
  const svg = d3.select("#"+id)
  let g = svg.append("g")

  const margin = 25
  const width = 400
  const height = 700

  const maxVal = d3.max(entries, (d) => d.time)

  const y = d3.scaleBand()
    .domain(d3.groupSort(entries, ([d]) => -d.time, (d) => d.word))
    .range([margin, height-margin])
    .padding(.2)

  const x = d3.scaleLinear().domain([-maxVal, maxVal]).range([margin,width-margin])
  
  g.selectAll().data(entries)
     .join("rect")
        .attr("y", (d) => y(d.word))
        .attr("height", y.bandwidth())
        .attr("width", (d) => x(d.time)-x(0))
        .append("svg:title").text((d) => d.word)
  g.selectAll("text").data(entries).enter()
      .append("text")
        .text((d) => d.time)
        .attr("y", (d) => y(d.word)+y.bandwidth()-1)
        .style("fill", "white")
        .style("font-size", y.bandwidth()+"px")

      g.selectAll("rect").data(entries)
      .attr("fill", (d) => d3.hsl(20, 0.75, d.freq === "high" ? 0.6 : 0.4).formatHex())
      .attr("x", (d) => {
        if(d.freq === "low") {
          return x(-d.time)
        } else {
          return x(0)
        }
      })
      g.selectAll("text").data(entries)
        .attr("x", (d) => {
          if(d.freq === "low") {
            return x(-d.time)+10
          }
          else {
            return x(d.time)-10
          }
          })
        .style("text-anchor", (d) => d.freq === "low" ? "start" : "end")

}

func getData(db *pgxpool.Pool) ([]entry, error) {
	var entries []entry
	values, err := db.Query(context.Background(),
		`SELECT wp.word, avg(r.time) as time, wp.freq, wp.aoa from results as r 
		inner join 
		"wordPairs" as wp on wp.id = r.pair_id where r.correct = true and r.word = true
		group by wp.word, wp.aoa, wp.freq`,
	)
	defer values.Close()
	if err != nil {
		return nil, err
	}
	for values.Next() {
		var entry entry
		values.Scan(&entry.Word, &entry.Time, &entry.Freq, &entry.Aoa)
		entries = append(entries, entry)
	}
	return entries, nil

}

func BifurcatedFrequencyHistogram(db *pgxpool.Pool) templ.Component {
	entries, err := getData(db)

	if err != nil {
		fmt.Println("entries error: " + err.Error())

	}
	return displayHistogram(entries)

}

templ displayHistogram(entries []entry) {
	@graphBase(
		"Word Time By Frequency",
		`On the left are words with a low frequency in english, 
													      on the right are those with a higher frequency
													    `,
		svgComponent("0 0 400 700", "freqHisto"),
	)
	@listEntries(entries, "freqHisto")
}
